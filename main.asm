; ----------------------------------------------------
; ELTON SOARES SILVA
; 41711ETE010
; 16/06/2021
; CLOCK: 16 MHz
; Arduino UNO

; USO DOS REGISTRADORES:

; R20 E R21: 	GUARDAM PRÓXIMOS VALORES DO TMR1 RELATIVOS À FREQUÊNCIA A SER TOCADA
; R18 E R19: 	ARMAZENAM O Z COM ENDEREÇO DA FREQUÊNCIA TOCADA, DPL E DPH RESPECTIVAMENTE


; R25: 			GUARDA QUANTAS VEZES O TMR2 ESTOUROU P/ AUXILIAR A TROCAR A NOTA

; R17:	 		REG. PARA AUXILIAR A RESETAR A MÚSICA QUANDO TODAS AS NOTAS TIVEREM SIDO TOCADAS

; R23 E R24: 	ARMAZENAM O Z COM ENDEREÇO DA DURAÇÃO DA ATUAL NOTA
; R22: 			GUARDA QUANTAS VEZES DETERMINADA NOTA DEVERÁ SER TOCADA

; R16 E R0:		AUXILIAM A INVERTER O ESTADO DE PB.0
; R16:			AINDA AJUDA A CONFIGURAR OS REGISTRADORES PARA HABILITAR OS TIMERS

; ----------------------------------------------------

; NOTAS UNDERWORLD THEME
.EQU C41 = 0xFE
.EQU C42 = 0x22

.EQU C51 = 0xFF
.EQU C52 = 0x10

.EQU A31 = 0xFD
.EQU A32 = 0xF7

.EQU A41 = 0xFE
.EQU A42 = 0xE3

.EQU AS31 = 0xFD
.EQU AS32 = 0xE7

.EQU AS41 = 0xFE
.EQU AS42 = 0xF3

.EQU F31 = 0xFD
.EQU F32 = 0x35

.EQU F41 = 0xFE
.EQU F42 = 0x99

.EQU D31 = 0xFC
.EQU D32 = 0xAD

.EQU D41 = 0xFE
.EQU D42 = 0x56

.EQU DS31 = 0xFC
.EQU DS32 = 0xDE

.EQU DS41 = 0xFE
.EQU DS42 = 0x6E

.EQU CS41 = 0xFE
.EQU CS42 = 0x3C

.EQU GS31 = 0xFD
.EQU GS32 = 0xA7

.EQU G31 = 0xFD
.EQU G32 = 0x82

.EQU FS41 = 0xFE
.EQU FS42 = 0xAE

.EQU E31 = 0xFD
.EQU E32 = 0x0A

.EQU GS41 = 0xFE
.EQU GS42 = 0xD2

.EQU B31 = 0xFE
.EQU B32 = 0x05

; ----------------------------------------------------

.device ATmega328P
.include "./m328Pdef.inc"

.ORG 0x0000
	JMP CONFIGS

; INTERRUPT ------------------- TIMER1 | COMPLEMENTA PB0
.ORG 0x001A
	CALL INTERRUPT_TIMER1
	RETI

; INTERRUPT ------------------- TIMER2 | TEMPORIZA NOTA
.ORG 0x0012
	CALL INTERRUPT_TIMER2
	RETI

.ORG 0x0050
; CONFIGURA TIMERS 1 E 2
CONFIGS:

	LDI R16, 0xFF			; R16 = 0000 0001
	OUT DDRB, R16			; PORTB.0 SERÁ SAÍDA E O RESTO ENTRADA

	LDI R16, 0x80			; R16 = 1000 0000
	OUT SREG, R16			; SREG.I = 1 | HABILITA INTERRUPTS SETANDO I - GLOBAL INTERRUPT

	; TMR1
	LDI R16, 0x00			; R16 = 0
	STS TCCR1A, R16			; TCCR1A = 0
	LDI R16, 0b00000011		; R16 = 0x03
	STS TCCR1B, R16			; SETA CS11 E CS10, CONFIGURANDO PRESCALER = 64

	; CARREGA TMR1 COM A PRIMEIRA NOTA
	LDI ZL, low(underworld*2)		; PEGA BYTE MENOS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA NOTA NA TABELA UNDERWORLD
	LDI ZH, high(underworld*2)		; PEGA BYTE MAIS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA NOTA NA TABELA UNDERWORLD
	;INC ZL
	LPM R21, Z						; PEGA O CONTEÚDO (BYTE MAIS SIGNIFICATIVO DA NOTA)
	INC ZL							; INCREMENTA O ENDEREÇO
	LPM R20, Z						; PEGA O BYTE MENOS SIGNIFICATIVO DA NOTA
	STS TCNT1H, R21					; CARREGA O BYTE MAIS SIG. NO REG DO TMR1
	STS TCNT1L, R20					; CARREGA O BYTE MENOS SIG. NO REG DO TMR1
	MOV R18, ZL						; ARMAZENA ENDEREÇO DA FREQ. NOTA ATUAL
	MOV R19, ZH						; ARMAZENA ENDEREÇO DA FREQ. NOTA ATUAL


	; INICIA TMR1
	LDI R16, 0x01			; R16 = 0000 0001
	STS TIMSK1, R16			; TOIE1 = 1

	; TMR2
	LDI R16, 0x00
	STS TCCR2A, R16
	LDI R16, 0b00000111		; PRESCALER DE 1024
	STS TCCR2B, R16

	LDI ZL, low(temporizacao*2)			; PEGA BYTE MENOS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA DURAÇÃO DA 1ª NOTA
	LDI ZH, high(temporizacao*2)		; PEGA BYTE MAIS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA DURAÇÃO DA 1ª NOTA
	LPM R22, Z							; PEGA O CONTEÚDO (DURAÇÃO DA NOTA ATUAL, OU SEJA, QUANTAS VEZES TMR2 DEVERÁ ESTOURAR)

	MOV R23, ZL							; ARMAZENA ENDEREÇO DA NOTA ATUAL
	MOV R24, ZH							; ARMAZENA ENDEREÇO DA NOTA ATUAL

	LDI R16, 0x00						; CARREGA COM 0 NO TMR2
	STS TCNT2, R16						; TCNT2 = 0

	LDI R16, 0x01						; R16 = 1
	STS TIMSK2, R16						; INICIA CONTAGEM TMR2


LOOP:
	LDI R17, 0x38						; R17 = 56 DECIMAL
	CPSE R17, R25						; R17 = R25 ? SE SIM, TOCOU TODA A MÚSICA.
	JMP LOOP							; LOOP INFINITO
	LDI R25, 0x00						; R25 = 0
	LDI ZL, low(underworld*2)			; PEGA BYTE MENOS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA NOTA NA TABELA UNDERWORLD
	LDI ZH, high(underworld*2)			; PEGA BYTE MAIS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA NOTA NA TABELA UNDERWORLD
	LPM R21, Z							; PEGA O CONTEÚDO (BYTE MAIS SIGNIFICATIVO DA NOTA)
	INC ZL								; INCREMENTA O ENDEREÇO
	LPM R20, Z							; PEGA O BYTE MENOS SIGNIFICATIVO DA NOTA
	STS TCNT1H, R21						; CARREGA O BYTE MAIS SIG. NO REG DO TMR1
	STS TCNT1L, R20						; CARREGA O BYTE MENOS SIG. NO REG DO TMR1
	MOV R18, ZL							; ARMAZENA ENDEREÇO DA FREQ. NOTA ATUAL
	MOV R19, ZH							; ARMAZENA ENDEREÇO DA FREQ. NOTA ATUAL
	LDI ZL, low(temporizacao*2)			; PEGA BYTE MENOS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA DURAÇÃO DA 1ª NOTA
	LDI ZH, high(temporizacao*2)		; PEGA BYTE MAIS SIGNIFICATIVO DO ENDEREÇO DA PRIMEIRA DURAÇÃO DA 1ª NOTA
	LPM R22, Z							; PEGA O CONTEÚDO (DURAÇÃO DA NOTA ATUAL, OU SEJA, QUANTAS VEZES TMR2 DEVERÁ ESTOURAR)
	MOV R23, ZL							; ARMAZENA ENDEREÇO DA NOTA ATUAL
	MOV R24, ZH							; ARMAZENA ENDEREÇO DA NOTA ATUAL
	JMP LOOP

INTERRUPT_TIMER1:						; COMPLEMENTA PB0
	LDI R16, 0x00						; R30 = 0
	CPSE R21, R16						; R21 = R30? SE SIM, PULA A PRÓXIMA INSTRUÇÃO E NÃO INVERTE O ESTADO DE PB0
	CALL COMPLEMENTA_PB0				; CHAMA SUB-ROTINA PARA INVERTER A PORTA	
	RETI

COMPLEMENTA_PB0:
	LDI R16, 0x01						; R7 = 0000 0001
	EOR R0, R16							; R29 = R29 XOR R7
	OUT PORTB, R0						; PORTB = R29

	STS TCNT1H, R21						; CARREGA O BYTE MAIS SIG. DA FREQ. NO REG DO TMR1
	STS TCNT1L, R20						; CARREGA O BYTE MENOS SIG. DA FREQ. NO REG DO TMR1
	RETI

INTERRUPT_TIMER2:						; TEMPORIZA AS NOTAS
	
	; PASSA PARA A PRÓXIMA DURAÇÃO DE NOTA SE R22 = 0
	LDI R16, 0x00						; R30 = 0
	DEC R22								; R22 = R22 - 1
	CPSE R22, R16						; R22 = R16 = 0? SE SIM, PULA O RETI E TROCA A NOTA, SE NÃO, NÃO TROCA A NOTA
	RETI
	MOV ZL, R23							; Z = R24R23-> DEVOLVE ENDEREÇO DA DURAÇÃO DA NOTA ATUAL
	MOV ZH, R24
	INC ZL								; PASSA PARA A PRÓXIMA NOTA
	LPM R22, Z							; PEGA O CONTEÚDO (DURAÇÃO DA NOTA ATUAL, OU SEJA, QUANTAS VEZES TMR2 DEVERÁ ESTOURAR)
	MOV R23, ZL							; ARMAZENA ENDEREÇO DA DURAÇÃO NOTA ATUAL
	MOV R24, ZH							; ARMAZENA ENDEREÇO DA DURAÇÃO DA NOTA ATUAL

	; PASSA PARA A PRÓXIMA NOTA
	MOV ZL, R18							; Z = R19R18 -> DEVOLVE ENDEREÇO DA NOTA ATUAL
	MOV ZH, R19
	INC ZL								; PASSA PARA O BYTE MAIS SIG. PRÓXIMA NOTA
	LPM R21, Z							; R21 = BYTE MAIS SIG. DA PRÓX. NOTA
	INC ZL								; PASSA PARA O BYTE MENOS SIG. PRÓXIMA NOTA
	LPM R20, Z							; R20 = BYTE MENOS SIG. DA PRÓX. NOTA
	MOV R19, ZH							; ARMAZENA ENDEREÇO DA NOTA ATUAL
	MOV R18, ZL							; ARMAZENA ENDEREÇO DA NOTA ATUAL

	INC R25								; INCREMENTA R25 P/ INDICAR QUE TROCOU DE NOTA

	RETI

.ORG 0x0200
; Look-Up table música Underworld theme
underworld:
.DB C41, C42, C51, C52, A31, A32, A41, A42
.DB AS31, AS32, AS41, AS42, 0x00, 0x00
.DB 0x00, 0x00
.DB C41, C42, C51, C52, A31, A32, A41, A42
.DB AS31, AS32, AS41, AS42, 0x00, 0x00
.DB 0x00, 0x00
.DB F31, F32, F41, F42, D31, D32, D41, D42
.DB DS31, DS32, DS41, DS42, 0x00, 0x00
.DB 0x00, 0x00
.DB F31, F32, F41, F42, D31, D32, D41, D42
.DB DS31, DS32, DS41, DS42, 0x00, 0x00
.DB 0x00, 0x00, DS41, DS42, CS41, CS42, D41, D42
.DB CS41, CS42, DS41, DS42
.DB DS41, DS42, GS31, GS32
.DB G31, G32, CS41, CS42
.DB C41, C42, FS41, FS42, F41, F42, E31, E32, AS41, AS42
.DB A41, A42
.DB GS41, GS42, DS41, DS42, B31, B32
.DB AS31, AS32, A31, A32, GS31, GS32
.DB 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

.ORG 0x0400
; look-up table da temporização das notas
temporizacao:
.DB 12, 12, 12, 12, 12, 12, 16, 16, 12, 12, 12, 12, 12, 12, 16, 16, 12, 12, 12, 12, 12, 12, 16, 16, 12, 12, 12, 12, 12, 12, 8, 8, 16, 16, 16, 8, 8, 8, 8, 8, 8, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 8, 8, 8